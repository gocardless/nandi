# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cells` gem.
# Please instead update this file by running `bin/tapioca gem cells`.


# source://cells//lib/cell/version.rb#1
module Cell; end

# source://cells//lib/cell/abstract.rb#1
module Cell::Abstract
  # source://cells//lib/cell/abstract.rb#2
  def abstract!; end

  # @return [Boolean]
  #
  # source://cells//lib/cell/abstract.rb#6
  def abstract?; end
end

# source://cells//lib/cell/builder.rb#4
module Cell::Builder
  include ::Declarative::Builder

  mixes_in_class_methods ::Declarative::Builder::DSL
  mixes_in_class_methods ::Declarative::Builder::Build
  mixes_in_class_methods ::Cell::Builder::ClassMethods

  class << self
    # @private
    #
    # source://cells//lib/cell/builder.rb#5
    def included(base); end
  end
end

# source://cells//lib/cell/builder.rb#10
module Cell::Builder::ClassMethods
  # source://cells//lib/cell/builder.rb#11
  def build(*args); end
end

# source://cells//lib/cell/caching.rb#4
module Cell::Caching
  mixes_in_class_methods ::Cell::Caching::ClassMethods
  mixes_in_class_methods ::Uber::InheritableAttr

  # @return [Boolean]
  #
  # source://cells//lib/cell/caching.rb#58
  def cache?(state, *args); end

  # we want to use DI to set a cache store in cell/rails.
  #
  # source://cells//lib/cell/caching.rb#54
  def cache_store; end

  # source://cells//lib/cell/caching.rb#44
  def render_state(state, *args); end

  private

  # source://cells//lib/cell/caching.rb#68
  def fetch_from_cache_for(key, options, &block); end

  # @return [Boolean]
  #
  # source://cells//lib/cell/caching.rb#64
  def perform_caching?; end

  # @return [Boolean]
  #
  # source://cells//lib/cell/caching.rb#72
  def state_cached?(state); end

  class << self
    # @private
    #
    # source://cells//lib/cell/caching.rb#5
    def included(includer); end
  end
end

# source://cells//lib/cell/caching.rb#19
module Cell::Caching::ClassMethods
  # source://cells//lib/cell/caching.rb#20
  def cache(state, *args, &block); end

  # source://cells//lib/cell/caching.rb#33
  def expire_cache_key_for(key, cache_store, *args); end

  # Computes the complete, namespaced cache key for +state+.
  #
  # source://cells//lib/cell/caching.rb#29
  def state_cache_key(state, key_parts = T.unsafe(nil)); end

  private

  # source://cells//lib/cell/caching.rb#39
  def expand_cache_key(key); end
end

# source://cells//lib/cell/collection.rb#2
class Cell::Collection
  include ::Cell::Collection::Call
  include ::Cell::Collection::Layout
  extend ::Gem::Deprecate

  # @return [Collection] a new instance of Collection
  #
  # source://cells//lib/cell/collection.rb#3
  def initialize(ary, options, cell_class); end

  # Sets the attribute collection_join
  #
  # @param value the value to set the attribute collection_join to.
  def collection_join=(*args, **_arg1, &block); end

  # Iterate collection and build a cell for each item.
  # The passed block receives that cell and the index.
  # Its return value is captured and joined.
  #
  # source://cells//lib/cell/collection.rb#32
  def join(separator = T.unsafe(nil), &block); end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  def method=(*args, **_arg1, &block); end

  # TODO: remove in 5.0.
  #
  # source://cells//lib/cell/collection.rb#12
  def set_deprecated_options(options); end

  # source://cells//lib/cell/collection.rb#25
  def to_s; end

  private

  # source://cells//lib/cell/collection.rb#51
  def _deprecated_collection_join=(_arg0); end

  # source://cells//lib/cell/collection.rb#51
  def _deprecated_method=(_arg0); end

  # Returns the value of attribute collection_join.
  #
  # source://cells//lib/cell/collection.rb#51
  def collection_join; end

  # Returns the value of attribute method.
  #
  # source://cells//lib/cell/collection.rb#51
  def method; end
end

# source://cells//lib/cell/collection.rb#17
module Cell::Collection::Call
  # source://cells//lib/cell/collection.rb#18
  def call(state = T.unsafe(nil)); end
end

# source://cells//lib/cell/collection.rb#39
module Cell::Collection::Layout
  # WARNING: THIS IS NOT FINAL API.
  #
  # source://cells//lib/cell/collection.rb#40
  def call(*_arg0); end
end

# Cell::Concept is no longer under active development. Please switch to Trailblazer::Cell.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://cells//lib/cell/concept.rb#5
class Cell::Concept < ::Cell::ViewModel
  extend ::Cell::SelfContained
  extend ::Cell::SelfContained::Prefixes

  # source://cells//lib/cell/view_model.rb#64
  def concept(name, model = T.unsafe(nil), options = T.unsafe(nil)); end

  class << self
    # source://cells//lib/cell/concept.rb#12
    def class_from_cell_name(name); end

    # source://cells//lib/cell/concept.rb#16
    def controller_path; end
  end
end

# source://cells//lib/cell/prefixes.rb#1
module Cell::Prefixes
  mixes_in_class_methods ::Cell::Prefixes::ClassMethods

  # source://cells//lib/cell/prefixes.rb#6
  def _prefixes; end

  class << self
    # @private
    #
    # source://cells//lib/cell/prefixes.rb#2
    def included(includer); end
  end
end

# You're free to override those methods in case you want to alter our view inheritance.
#
# source://cells//lib/cell/prefixes.rb#11
module Cell::Prefixes::ClassMethods
  # source://cells//lib/cell/prefixes.rb#12
  def prefixes; end

  private

  # source://cells//lib/cell/prefixes.rb#22
  def _local_prefixes; end

  # source://cells//lib/cell/prefixes.rb#17
  def _prefixes; end

  # Instructs Cells to inherit views from a parent cell without having to inherit class code.
  #
  # source://cells//lib/cell/prefixes.rb#27
  def inherit_views(parent); end
end

# Enforces the new trailblazer directory layout where cells (or concepts in general) are
# fully self-contained in its own directory.
#
# source://cells//lib/cell/self_contained.rb#3
module Cell::SelfContained
  # source://cells//lib/cell/self_contained.rb#4
  def self_contained!; end
end

# source://cells//lib/cell/self_contained.rb#8
module Cell::SelfContained::Prefixes
  # source://cells//lib/cell/self_contained.rb#9
  def _local_prefixes; end
end

# source://cells//lib/cell.rb#8
class Cell::TemplateMissingError < ::RuntimeError
  # @return [TemplateMissingError] a new instance of TemplateMissingError
  #
  # source://cells//lib/cell.rb#9
  def initialize(prefixes, view); end
end

# Gets cached in production.
#
# source://cells//lib/cell/templates.rb#3
class Cell::Templates
  # prefixes could be instance variable as they will never change.
  #
  # source://cells//lib/cell/templates.rb#5
  def [](prefixes, view, options); end

  private

  # source://cells//lib/cell/templates.rb#11
  def cache; end

  # source://cells//lib/cell/templates.rb#22
  def create(prefix, view, options); end

  # options is not considered in cache key.
  #
  # source://cells//lib/cell/templates.rb#15
  def find_template(prefixes, view, options); end
end

# {["comment/row/views", comment/views"]["show.haml"] => "Tpl:comment/view/show.haml"}
#
# source://cells//lib/cell/templates.rb#31
class Cell::Templates::Cache
  # @return [Cache] a new instance of Cache
  #
  # source://cells//lib/cell/templates.rb#32
  def initialize; end

  # Iterates prefixes and yields block. Returns and caches when block returned template.
  # Note that it caches per prefixes set as this will most probably never change.
  #
  # source://cells//lib/cell/templates.rb#38
  def fetch(prefixes, view); end

  private

  # ["comment/views"] => "show.haml"
  #
  # source://cells//lib/cell/templates.rb#48
  def get(prefixes, view); end

  # source://cells//lib/cell/templates.rb#53
  def store(prefix, view, template); end
end

# Builder methods and Capybara support.
# This gets included into Test::Unit, MiniTest::Spec, etc.
#
# source://cells//lib/cell/testing.rb#6
module Cell::Testing
  include ::Cell::Testing::ControllerFor

  mixes_in_class_methods ::Uber::InheritableAttr

  # source://cells//lib/cell/testing.rb#7
  def cell(name, *args); end

  # source://cells//lib/cell/testing.rb#11
  def concept(name, *args); end

  private

  # source://cells//lib/cell/testing.rb#16
  def cell_for(baseclass, name, model = T.unsafe(nil), options = T.unsafe(nil)); end

  # FIXME: this won't allow us using let(:controller) in MiniTest.
  #
  # source://cells//lib/cell/testing.rb#59
  def controller; end

  class << self
    # Set this to true if you have Capybara loaded. Happens automatically in Cell::TestCase.
    #
    # source://cells//lib/cell/testing.rb#30
    def capybara=(value); end

    # @return [Boolean]
    #
    # source://cells//lib/cell/testing.rb#34
    def capybara?; end

    # @private
    #
    # source://cells//lib/cell/testing.rb#63
    def included(base); end
  end
end

# Extends ViewModel#call by injecting Capybara support.
#
# source://cells//lib/cell/testing.rb#39
module Cell::Testing::Capybara
  # source://cells//lib/cell/testing.rb#46
  def call(*_arg0); end
end

# source://cells//lib/cell/testing.rb#40
module Cell::Testing::Capybara::ToS
  # source://cells//lib/cell/testing.rb#41
  def to_s; end
end

# source://cells//lib/cell/testing.rb#51
module Cell::Testing::ControllerFor
  # This method is provided by the cells-rails gem.
  #
  # source://cells//lib/cell/testing.rb#53
  def controller_for(controller_class); end
end

# source://cells//lib/cell/util.rb#1
module Cell::Util
  # source://cells//lib/cell/util.rb#2
  def util; end
end

# source://cells//lib/cell/util.rb#6
class Cell::Util::Inflector
  class << self
    # WARNING: this API might change.
    #
    # source://cells//lib/cell/util.rb#17
    def constant_for(name); end

    # copied from ActiveSupport.
    #
    # source://cells//lib/cell/util.rb#8
    def underscore(constant); end
  end
end

# source://cells//lib/cell/version.rb#2
Cell::VERSION = T.let(T.unsafe(nil), String)

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://cells//lib/cell/layout.rb#2
class Cell::ViewModel
  include ::Cell::Prefixes
  include ::Cell::ViewModel::Rendering
  include ::Cell::Caching
  include ::Cell::ViewModel::TemplateFor
  include ::Cell::ViewModel::ProcessOptions
  include ::Cell::ViewModel::Layout
  extend ::Cell::Abstract
  extend ::Uber::InheritableAttr
  extend ::Uber::Delegates
  extend ::Cell::Prefixes::ClassMethods
  extend ::Cell::Util
  extend ::Cell::ViewModel::Helpers
  extend ::Cell::Caching::ClassMethods
  extend ::Cell::ViewModel::Layout::ClassMethods

  # @return [ViewModel] a new instance of ViewModel
  #
  # source://cells//lib/cell/view_model.rb#70
  def initialize(model = T.unsafe(nil), options = T.unsafe(nil)); end

  # Build nested cell in instance.
  #
  # source://cells//lib/cell/view_model.rb#64
  def cell(name, model = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://cells//lib/cell/view_model.rb#74
  def context; end

  # Returns the value of attribute model.
  #
  # source://cells//lib/cell/view_model.rb#27
  def model; end

  # source://cells//lib/cell/view_model.rb#124
  def to_s; end

  private

  # source://cells//lib/cell/view_model.rb#178
  def normalize_options(options); end

  # Returns the value of attribute options.
  #
  # source://cells//lib/cell/view_model.rb#130
  def options; end

  # called from the precompiled template. FIXME: this is currently not used in Haml.
  #
  # source://cells//lib/cell/view_model.rb#153
  def output_buffer; end

  # source://cells//lib/cell/view_model.rb#132
  def setup!(model, options); end

  # Computes the view name from the call stack in which `render` was invoked.
  #
  # source://cells//lib/cell/view_model.rb#200
  def state_for_implicit_render(options); end

  class << self
    # semi-public for Cell::Builder
    def build(*_arg0); end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#10
    def cache_options; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#6
    def cache_options=(v); end

    # Public entry point. Use this to instantiate cells with builders.
    #
    #   SongCell.(@song)
    #   SongCell.(collection: Song.all)
    #
    # source://cells//lib/cell/view_model.rb#47
    def call(model = T.unsafe(nil), options = T.unsafe(nil), &block); end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#10
    def conditional_procs; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#6
    def conditional_procs=(v); end

    # source://cells//lib/cell/view_model.rb#23
    def controller_path; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#10
    def layout_name; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#6
    def layout_name=(v); end

    # source://cells//lib/cell/view_model.rb#39
    def property(*names); end

    # source://cells//lib/cell/view_model.rb#15
    def templates; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#10
    def version_procs; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#6
    def version_procs=(v); end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#10
    def view_paths; end

    # source://uber/0.1.0/lib/uber/inheritable_attr.rb#6
    def view_paths=(v); end

    private

    # source://cells//lib/cell/view_model.rb#58
    def class_from_cell_name(name); end
  end
end

# DISCUSS: we could use the same mechanism as TRB::Skills here for speed at runtime?
#
# source://cells//lib/cell/view_model.rb#79
class Cell::ViewModel::Context
  class << self
    # Only dup&merge when :context was passed in parent.cell(context: ..)
    # Otherwise we can simply pass on the old context.
    #
    # source://cells//lib/cell/view_model.rb#82
    def [](options, context); end
  end
end

# source://cells//lib/cell/escaped.rb#1
module Cell::ViewModel::Escaped
  mixes_in_class_methods ::Cell::ViewModel::Escaped::Property

  # source://cells//lib/cell/escaped.rb#27
  def escape!(string); end

  class << self
    # @private
    #
    # source://cells//lib/cell/escaped.rb#2
    def included(includer); end
  end
end

# source://cells//lib/cell/escaped.rb#6
module Cell::ViewModel::Escaped::Property
  # source://cells//lib/cell/escaped.rb#7
  def property(*names); end
end

# source://cells//lib/cell/view_model.rb#29
module Cell::ViewModel::Helpers
  # Constantizes name if needed, call builders and returns instance.
  #
  # source://cells//lib/cell/view_model.rb#31
  def cell(name, *args, &block); end
end

# Set the layout per cell class. This is used in #render calls. Gets inherited to subclasses.
#
# source://cells//lib/cell/layout.rb#4
module Cell::ViewModel::Layout
  mixes_in_class_methods ::Cell::ViewModel::Layout::ClassMethods

  private

  # source://cells//lib/cell/layout.rb#17
  def process_options!(options); end

  # source://cells//lib/cell/layout.rb#32
  def render_layout(name, options, content); end

  # source://cells//lib/cell/layout.rb#22
  def render_to_string(options, &block); end

  # source://cells//lib/cell/layout.rb#26
  def with_layout(options, content); end

  class << self
    # @private
    #
    # source://cells//lib/cell/layout.rb#5
    def included(base); end
  end
end

# source://cells//lib/cell/layout.rb#10
module Cell::ViewModel::Layout::ClassMethods
  # source://cells//lib/cell/layout.rb#11
  def layout(name); end
end

# Allows using a separate layout cell which will wrap the actual content.
# Use like cell(..., layout: Cell::Layout)
#
# Note that still allows the `render layout: :application` option.
#
# source://cells//lib/cell/layout.rb#41
module Cell::ViewModel::Layout::External
  # source://cells//lib/cell/layout.rb#42
  def call(*_arg0); end
end

# WARNING: THIS IS NOT FINAL API.
#
# source://cells//lib/cell/layout.rb#47
Cell::ViewModel::Layout::External::Render = T.let(T.unsafe(nil), Proc)

# source://cells//lib/cell/view_model.rb#138
class Cell::ViewModel::OutputBuffer < ::Array
  # source://cells//lib/cell/view_model.rb#143
  def <<(string); end

  # source://cells//lib/cell/view_model.rb#143
  def append=(string); end

  # source://cells//lib/cell/view_model.rb#139
  def encoding; end

  # source://cells//lib/cell/view_model.rb#143
  def safe_append=(string); end

  # output_buffer is returned at the end of the precompiled template.
  #
  # source://cells//lib/cell/view_model.rb#149
  def to_s; end
end

# Overwrite #process_options in included feature modules, but don't forget to call +super+.
#
# source://cells//lib/cell/view_model.rb#193
module Cell::ViewModel::ProcessOptions
  # source://cells//lib/cell/view_model.rb#194
  def process_options!(options); end
end

# source://cells//lib/cell/view_model.rb#88
module Cell::ViewModel::Rendering
  # Invokes the passed method (defaults to :show) while respecting caching.
  # In Rails, the return value gets marked html_safe.
  #
  # source://cells//lib/cell/view_model.rb#91
  def call(state = T.unsafe(nil), *args, &block); end

  # render :show
  #
  # source://cells//lib/cell/view_model.rb#102
  def render(options = T.unsafe(nil), &block); end

  # Since 4.1, you get the #show method for free.
  #
  # source://cells//lib/cell/view_model.rb#97
  def show(&block); end

  private

  # source://cells//lib/cell/view_model.rb#113
  def render_state(*args, &block); end

  # source://cells//lib/cell/view_model.rb#117
  def render_template(template, options, &block); end

  # source://cells//lib/cell/view_model.rb#108
  def render_to_string(options, &block); end
end

# source://cells//lib/cell/view_model.rb#157
module Cell::ViewModel::TemplateFor
  # source://cells//lib/cell/view_model.rb#158
  def find_template(options); end

  # source://cells//lib/cell/view_model.rb#170
  def template_for(prefixes, view, options); end
end
